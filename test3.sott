define sum :
  Set -> Set -> Set
as \A -> \B -> (x : Bool) * x by_cases for x. Set { True -> A; False -> B }

define inl :
  (A:Set)(B:Set) -> A -> sum A B
as \A -> \B -> \a -> (True, a)

(* Failure of canonicity -- see notebook *)

define and :
  Bool -> Bool -> Bool
as \x -> \y -> x by_cases for y. Bool { True -> y; False -> False }

(* An easier to use functional extensionality principle *)
define funext2 :
  (S : Set)(T : S -> Set)(f : (x : S) -> T x)(g : (x : S) -> T x) ->
  ((x : S) -> [f x : T x = g x : T x]) ->
  [f : (x : S) -> T x = g : (x : S) -> T x]
as \S -> \T -> \f -> \g -> \e ->
   funext (x1 x2 xe. coerce(e x1,
                            [f x1 : T x1 = g x1 : T x1],
                            [f x1 : T x1 = g x2 : T x2],
                            subst(S,y.[f x1 : T x1 = g y : T y],x1,x2,xe)))

define eq_funcs :
  [ \b -> False : Bool -> Bool = \b -> and b False : Bool -> Bool]
as
  funext2 Bool (\x -> Bool) (\b -> False) (\b -> and b False) 
    (\b -> b by_cases for b. [False : Bool = and b False : Bool ]
                { True -> refl; False -> refl })

define F : (Bool -> Bool) -> Set
as \f -> sum [f : Bool -> Bool = \x -> False : Bool -> Bool] [f : Bool -> Bool = \x -> True : Bool -> Bool]

define v : F (\x -> False)
as (True, refl)

define hofmann2 : F (\x -> and x False)
as coerce(v, F (\x -> False), F (\x -> and x False),
          subst(Bool -> Bool,x. F x, (\x -> False), (\x -> and x False), eq_funcs))

(*
define test :
  [hofmann : F (\x -> and x False) = (true, coerce
*)